/* Copyright (c) 2023 Codasip s.r.o.   */
/* SPDX-License-Identifier: Apache-2.0 */

/* Info: dts/bindings/base/base.yaml */

#include "skeleton.dtsi"
#include <zephyr/dt-bindings/gpio/gpio.h>
#include <zephyr/dt-bindings/pwm/pwm.h>
#include <freq.h>
#include <mem.h>
/* #include <zephyr/dt-bindings/interrupt-controller/codasip-l31helium-pic.h> */

/ {
        #address-cells = <1>;
        #size-cells = <1>;

        compatible = "codasip,l31helium" /*, "codasip-l31helium", "l31helium"*/;
/*        model = "codasip-l31helium"; generates an error */
        clocks {
                coreclk: core-clk {
                        #clock-cells = <0>;
                        compatible = "fixed-clock";
                        clock-frequency = <DT_FREQ_M(25)>;
                };

                tlclk: tl-clk {
                        #clock-cells = <0>;
                        compatible = "fixed-factor-clock";
                        clocks = <&coreclk>;
                        clock-div = <1>;
                };
        };

        cpus {
                #address-cells = <1>;
                #size-cells = <0>;
                timebase-frequency = <25000000>;
                cpu@0 {
                        /*compatible = "codasip,l31helium", "codasip-l31helium"; */
                        compatible = "riscv";
                        device_type = "cpu";
                        reg = <0>;
                        riscv,isa = "rv32imfcb";
                        clock-frequency = <25000000>;
                        status = "okay";
                        intc: interrupt-controller {
                                compatible = "riscv,cpu-intc";
                                #address-cells = <0>;
                                #interrupt-cells = <1>;
                                interrupt-controller;
                        };
                };
        };
/*        dram: memory@0 {
                device_type = "memory";
                compatible = "mmio-sram";
                reg = <0x80000000 0xC0000000>;
        }; */

        soc {
                #address-cells = <1>;
                #size-cells = <1>;
/*                compatible = "codasip,l31helium", "codasip-l31helium", "l31helium"; */
                compatible = "simple-bus";
                ranges;

                sram0: memory@20000000 {
                        compatible = "mmio-sram";
                        reg = <0x20000000 DT_SIZE_K(512)>;
                };
                dram0: memory@80000000 {
                        compatible = "mmio-sram";
                        reg = <0x80000000 DT_SIZE_M(1024)>;
                };
                clint: clint@60010000 {
                        compatible = "sifive,clint0";
                        interrupts-extended = <&intc 3>, <&intc 7>;
                        reg = <0x60010000 0x1BFF8>;
                };
		/* Helium does not have a PLIC, only a Codasip PIC attached to CSR registers starting at 0x7C1.
		   The PIC just triggers the External Interrupt:
		      lib/include/baremetal/interrupt_low.h:    BM_INTERRUPT_MEIP = 11, // Machine external interrupt
		*/
                pic: pic {
                        compatible = "codasip,pic";
                        interrupt-controller;
                        interrupts-extended = <&intc 11>;
                        #interrupt-cells = <1>;	/* Only interrupt bit positions (no priority on the PIC) */
			interrupt-parent = <&intc>;
                        codasip-pic,ndev = <4>;	/* 4 Interrupts bits 3:0 */
                        status = "okay";
                };
/*                plic: plic@c000000 {
                        compatible = "sifive,plic-1.0.0";
                        #address-cells = <0>;
                        #interrupt-cells = <2>;
                        interrupt-controller;
                        interrupts-extended = <&intc 11>;
                        reg = <0x0 0x0c000000 0x0 0x00002000
                               0x0 0x0c002000 0x0 0x001fe000
                               0x0 0x0c200000 0x0 0x03e00000>;
                        reg-names = "prio", "irq_en", "reg";
                        riscv,max-priority = <255>;
                        riscv,ndev = <1023>;
                }; */
                uart0: serial@60101000 {
                        compatible = "ns16550";
                        clock-frequency = <25000000>;
                        reg = <0x60101000 0x1c>;
                        reg-shift = <2>;

                        interrupt-parent = <&pic>;
                        interrupts = <0>;	/* This is irq=267 (0x10B) returned by DT_IRQ_BY_IDX(DT_NODELABEL(uart0), 0, irq), 
						   which is correct -> 0x100 is the first IRQ (i.e. 0 [+ 1]) 2ND_LEVEL_INTERRUPTS,
						   while 0xB is 1st level interrupt &intc 11 */
                        status = "okay";
                };
                gpio00: gpio@60300000 {
                        compatible = "codasip,l31helium-gpio";
                        reg = <0x60300000 0x10>;
                        gpio-controller;
                        #gpio-cells = <2>;			/* What's this? */
                        ngpios = <8>;  				/* Number of GPIO pins. 
								   gpio_in[7:0]  =  SW[7:0]
								   gpio_out[7:0] = LED[7:0] */
                        status = "okay";
                };
                gpio01: gpio@60310000 {
                        compatible = "codasip,l31helium-gpio";
                        reg = <0x60310000 0x10>;
                        gpio-controller;
                        #gpio-cells = <2>;			/* What's this? */
                        ngpios = <4>;  				/* Number of GPIO pins. 
								   gpio_in[0]  = SD_CARD_DETECT_N
								   gpio_in[1]  = SD_PWR_EN_N
								   gpio_out[1] = SD_PWR_EN_N
								   gpio_out[2] = IRQ 2 (send interrupt request to the PIC)
								   gpio_out[3] = IRQ 3 (send interrupt request to the PIC) */
                        interrupt-parent = <&pic>;
                        interrupts = <2>, <3>;	/* <2> is irq=779 (0x30B) returned by DT_IRQ_BY_IDX(DT_NODELABEL(gpio01), 0, irq), 
						   which is correct -> 0x300 is the third IRQ (i.e. 2 [+ 1]) 2ND_LEVEL_INTERRUPTS,
						   while 0xB is 1st level interrupt &intc 11 */
                        			/* <3> is irq=1035 (0x40B) returned by DT_IRQ_BY_IDX(DT_NODELABEL(gpio01), 1, irq), 
						   which is correct -> 0x400 is the fourth IRQ (i.e. 3 [+ 1]) 2ND_LEVEL_INTERRUPTS,
						   while 0xB is 1st level interrupt &intc 11 */

						/* Note: 1st level interrupts start at 0, 2nd and 3rd level interrupts start at 1, 
						         as 0 in each of those byte positions = no interrupt */
						/* Note: IRQ numbering format is 0x44332211 where 0x33 = 3rd level irq, 
							 0x22 = 2nd level irq and 0x11 = 1st level irq.
							 0x44 is not used, set to 0x00 */
                        status = "okay";
                };
        };
};

